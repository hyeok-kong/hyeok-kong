### 카프카 스트림즈
토픽에 적재된 데이터를 상태기반(Stateful) 또는 비상태기반(Stateless)으로 실시간 변환하여 다른 토픽에 적재하는 라이브러리
#### 스트림즈를 사용해야 하는 이유?
- 카프카에서 공식적으로 지원함. 완벽하게 호환됨
- 스트림즈 혹은 브로커에서 장애가 발생하더라도 정확히 한번 할 수 있도록 하는 장애 허용 시스템(fault tolerant systm) 존재

#### 구성
- 내부적으로 1개 이상의 스레드 생성 가능
- 스레드는 1개 이상의 태스크를 가짐
	- 태스크 : 데이터 처리 최소 단위
		- 3개의 파티션을 가진 토픽을 처리하는 스트림즈는 3개의 태스크가 생김
- 스트림즈는 파티션, 스트림즈 스레드 개수를 늘림으로서 병렬 처리 가능
	- 컨슈머 그룹과 비슷한 방식

#### 구조
##### 토폴로지
카프카 스트림즈는 **트리형** 토폴로지와 유사함
##### 스트림
- **스트림** : 노드와 노드를 이은 선
	- 스트림은 토픽의 데이터를 의미
	- producer / consumer 에서의 레코드와 동일
##### 프로세서
- **프로세서** : 토폴로지를 이루는 하나의 노드
	- 소스 프로세서 / 스트림 프로세서 / 싱크 프로세서
- **소스 프로세서** 
	- 데이터를 처리하기 위해 최초로 선언해야 하는 노드
	- 하나 이상의 토픽에서 데이터를 가져오는 역할
- **스트림 프로세서**
	- 다른 프로세서가 반환한 데이터를 처리하는 역할
	- 변환, 분기처리와 같은 로직 등
- **싱크 프로세서
	- 데이터를 특정 카프카 토픽으로 저장
	- 스트림즈로 처리한 데이터의 최종 목적지

#### 개발
##### 스트림즈DSL(Domain Specific Language)
- 스트림 프로세싱에 쓰일 만한 다양한 기능들을 자체 API로 만들어놓음
##### 프로세서 API
- 스트림즈DSL에서 제공하지 않는 기능을 직접 구현할 때 사용

#### 스트림즈DSL
- 레코드의 흐름을 추상화한 3가지 개념 존재
	- KStream, KTable, GlobalKTable
	- 오직 스트림즈DSL 에서만 사용되는 개념임

##### KStream
- 레코드의 흐름을 표현한 것
- 메시지 키, 메시지 값으로 구성
- KStream으로 데이터를 조회하면 토픽 혹은 KStream에 존재하는 모든 레코드 출력
- 컨슈머가 토픽을 구독하는 것과 동일한 선상의 개념
##### KTable
- 메시지 키를 기준으로 묶어서 사용함
- 유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용
- SET과 유사한 개념임. 동일한 키의 새로 들어온 값이 유일한 키가 됨
- 1개 파티션이 1개 태스크에 할당되어 사용됨
##### GlobalKTable
- 모든 파티션 데이터가 각 태스크에 할당되어 사용됨
- 나머지는 KTable과 동일
- 대표적인 사용처는 **KStream**과 **KTable**을 조인하는 것
	- 조인 시 반드시 **코파티셔닝(co-partitioning)**, 즉 파티션 개수, 파티셔닝 전략이 동일해야 함
		- 동일하지 않을 경우 **리파티셔닝(repartitioning)** 을 통해 개수, 전략을 맞출 수 있음
		- 혹은 GlobalKTable 을 사용하면 됨
			- 모든 태스크에서 공유하기 때문
			- 데이터가 많다면 리파티셔닝 추천
				- GlobalKTable 사용 시 로컬 스토리지 사용량 부담
	- 메시지 키 뿐만 아니라 메시지 값을 통해서도 조인 가능함

#### 프로세서 API
Processor 인터페이스 혹은 Transformer 인터페이스를 구현하여 제작
