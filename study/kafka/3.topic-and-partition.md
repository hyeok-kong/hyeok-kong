### 토픽과 파티션
#### 적정 파티션 개수
##### 토픽 생성 시 파티션 개수 고려사항
- 데이터 처리량
- 메시지 키 사용 여부
- 브로커, 컨슈머 영향도
##### 파티션 개수 공식
>**프로듀서 전송 데이터량** < **컨슈머 데이터 처리량** * **파티션 개수**
- 절대로 지연이 발생하면 안되는 경우 최대 데이터량을 상정하고 설정
- 아닐 경우, 적절한 선에서 선택. (데이터가 적게 들어올 때 컨슈머 랙이 줄어듬)
##### 메시지 키 사용 여부
- 메시지 처리 순서가 보장되어야 한다면?
	- 파티션을 추가하기 위해선 커스텀 파티셔너를 적용해야 함
- 메시지 처리 순서를 지키지 않아도 된다면?
	- 파티션을 아무때나 늘려도 됨
	- 즉, 처음부터 파티션 개수를 넉넉하게 잡을 필요 없음
##### 브로커와 컨슈머의 영향도
- 파티션마다 파일이 생성됨
	- 즉, 파티션이 늘어나는 만큼 접근하는 파일 개수가 많아짐
	- 운영체제에선 프로세스당 열 수 있는 파일 최대 개수를 제한
- 파티션이 너무 많다면 브로커 개수 늘리는 걸 고려해야 함
#### 토픽 정리 정책 (cleanup.policy)
시간 또는 용량에 다라 삭제 규칙을 적용
##### 토픽 삭제 정책 (delete policy)
명시적으로 토픽의 데이터를 삭제하는 것
>cleanup.policy = delete
- 세그먼트 단위로 삭제 진행
	- 세그먼트는 파티션마다 별개로 생성
	- 세그먼트 파일 이름은 오프셋 중 가장 작은 값으로 설정됨
	- segment.bytes 옵션으로 1개 세그먼트의 크기를 설정할 수 있음
	- 데이터를 저장하기 위해 사용중인 세그먼트를 **액티브 세그먼트**라고 함
###### 토픽의 데이터를 유지하는 기간 설정
>retention.ms
- 일정 주기마다 세그먼트 파일의 마지막 수정 시간과 retention.ms를 비교
- 세그먼트 파일의 마지막 수정 시간이 설정을 넘어가면 세그먼트 삭제
>retention.bytes
- 크기를 넘어간 세그먼트 파일을 삭제함
##### 토픽 압축 정책 (compact policy)
압축 : 스트림즈의 KTable과 같이 메시지 키를 기반으로 가장 마지막 데이터만 남기는 것
>min.cleanable.dirty.ratio
- 액티브 세그먼트를 제외한 세그먼트에 남아 있는 데이터의
	- **tail 영역**의 레코드 개수와
		- 압축 정책에 의해 압축이 완료된 레코드들의 영역
		- **clean log** 라고 부름
	- **head 영역**의 레코드 개수의 비율
		- 정리되지 않은 레코드들의 영역, **dirty log**라고 부름
- ratio를 크게 설정하면
	- 한번 압축 할 때 많은 데이터가 줄어 압축 효과가 좋음
	- 그 전까지 용량을 차지하므로 용량 효율 안좋음
- ratio를 작게 설정하면
	- 압축이 더 자주 일어나 최신 데이터만 유지할 수 있음
	- 그만큼 브로커에게 부담을 줌
#### ISR (In-Sync-Replicas)
리더 파티션과 팔로워 파티션이 모두 싱크가 된 상태
>replica.lag.time.max.ms
- 팔로워 파티션이 데이터를 복제하는지 확인
- 위 설정보다 더 긴 시간동안 데이터를 가져가지 않았다면
	- 해당 팔로워 파티션에 문제가 생긴 것, ISR 그룹에서 제외함
>unclean.leader.election.enable
- ISR 그룹이 아닌 파티션은 리더로 선출될 자격이 없음
	- 유실이 발생하기 때문
- 유실이 발생해도 무중단 운영을 해야 할 경우
	- 위 옵션을 true로 설정
	- ISR이 아닌 팔로워 파티션을 리더로 선출할 수 있게 됨
- 유실이 발생하면 안되는 경우
	- 위 옵션을 false로 설정
	- 선출될 리더가 없을 경우 이슈가 발생한 브로커가 복구될 때 까지 중단됨
